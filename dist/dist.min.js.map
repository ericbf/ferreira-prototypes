{"version":3,"sources":["../src/Array.ts","../src/Function.ts","../src/HTMLElement.ts","../src/Object.ts","../src/String.ts"],"names":["Object","defineProperties","Array","prototype","remove","value","comp","thisArg","index","this","findIndex","splice","removeItem","item","fromIndex","indexOf","first","get","set","length","last","sortBy","defaultSorter","accessor","descending","lhs","rhs","lhv","rhv","recursiveSorter","order","sorters","propsOrOptionses","_i","arguments","propOrOptions","sorter","options","Boolean","property","prop_1","push","_a","propsOrOptionses_1","sort","contains","containsItem","$$memoizeUniqueId","Function","curry","args","that","apply","concat","slice","call","memoize","defaults","excludedArguments","argumentsCount","undefined","asynchronous","key","cache","keys","filter","obj","isFinite","subcache","argument","shift","defineProperty","e","JSON","stringify","String","catch","throttle","wait","immediate","timeout","func","context","setTimeout","debounce","clearTimeout","addAnimator","animator","window","requestAnimationFrame","now","HTMLElement","inDOM","document","documentElement","highestParent","parent","parentElement","isScrollable","style","getComputedStyle","overflowY","scrollableParent","parentTop","offset","totalOffsetTop","absoluteTop","element","scrollTop","offsetTop","offsetParent","parentLeft","totalOffsetLeft","absoluteLeft","scrollLeft","offsetLeft","scrollTo","topOrOptions","duration","timing","makeTween","start","end","valueMaker","x","Math","pow","time","_this","targetTop","targetLeft","startTime","performance","top","left","target_1","down_1","tween_1","expected_1","current","newScroll","target_2","right_1","tween_2","expected_2","scrollIntoViewIfNeeded","padding","scrollers","curr","child","viewport","width","clientWidth","height","clientHeight","offsetWidth","offsetHeight","forEach","merge","others","one","hasOwnProperty","desc","getOwnPropertyDescriptor","override","newFunc","_super","setWatcher","didSet","willSet","removeWatcher","addWatcher","_values","_willSets","_didSets","makeApplyer","newValue","oldValue","callback","enumerable","configurable","removeFromArray","arr","i","getNestedProperty","properties","properties_1","valuesArray","values","lowers","specials","expect","desire","ignores","str","caseInsensitve","RegExp","toRegExpEscaped","test","toTitleCase","replace","txt","charAt","toUpperCase","substr","toLowerCase","lowers_1","lower","specials_1","special","toSnakeCase","toCamelCase","_","match"],"mappings":"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","file":"dist.min.js","sourcesContent":["type Comparator<T> = (element: T, index: number, array: T[]) => boolean\ntype CompareFromArray<T> = (fromArray: T, item: T, index: number, array: T[]) => boolean\ntype Sorter<T> = (rhs: T, lhs: T) => number\ntype Accessor<T> = (item: T) => any\ntype SortOptions<T> = {\n\t/**\n\t * The property whose value to use in this sort operation.\n\t */\n\tproperty?: string\n\n\t/**\n\t * The accessor function that takes an item and returns a value to use in\n\t *   this sort operation.\n\t */\n\taccessor?: Accessor<T>\n\n\t/**\n\t * Whether to sort in descending order (as opposed to ascending). Default is\n\t *   `false`\n\t */\n\tdescending?: boolean\n\n\t/**\n\t * A custom sorter. Default is to use less/greater than operator.\n\t */\n\tsorter?: Sorter<T>\n}\n\ninterface Array<T> {\n\t/**\n\t * Removes the first instance of the item for which the comparator returns\n\t *   true. If there is no such item, this does nothing.\n\t *\n\t * @param comp - the custom comparator\n\t *\n\t * @return - the removed item or undefined if no item was removed\n\t */\n\tremove(comp: Comparator<T>, thisArg?: any): T | undefined\n\n\t/**\n\t * Removes the first instance of an item that is equal, according to ===.\n\t *   If there is no such item, this does nothing.\n\t *\n\t * @param item - the item to remove from the array\n\t *\n\t * @return - the removed item or undefined if it wasn't found in the array\n\t */\n\tremoveItem(item: T, thisArg?: any): T | undefined\n\n\t/**\n\t * Searches for an item using the comparator function, then returns that\n\t *   item.\n\t *\n\t * @return - that item or undefined\n\t */\n\tfind(comp: Comparator<T>, thisArg?: any): T | undefined\n\n\t/**\n\t * Searches for an item using the comparator function, returns index of\n\t *   that item, or -1 if not found.\n\t *\n\t * @return - that item's index or -1\n\t */\n\tfindIndex(comp: Comparator<T>, thisArg?: any): number | -1\n\n\t/**\n\t * The first item in this array, or undefined if there are no items.\n\t */\n\tfirst: T | undefined\n\n\t/**\n\t * The last item in this array, or undefined if there are no items.\n\t */\n\tlast: T | undefined\n\n\t/**\n\t * Sort this array in place by a property of each item in the array,\n\t *   breaking ties with other properties. You can also use sort options to\n\t *   determine the order.\n\t *\n\t * @param propsOrOptionses - the properties and/or sort options by which to\n\t *   sort and break ties.\n\t *\n\t * @return - this array, sorted\n\t */\n\tsortBy(...propsOrOptionses: (string | SortOptions<T>)[]): T[]\n\n\t/**\n\t * Returns whether an item for which the comparator returns true was found\n\t *   in the array.\n\t *\n\t * @param comp - the comparator to use\n\t *\n\t * @return - whether the item was found in the array\n\t */\n\tcontains(comp: Comparator<T>, thisArg?: any): boolean\n\n\t/**\n\t * Returns whether this item was found in the array.\n\t *\n\t * @param item - the item to check for\n\t *\n\t * @return - whether the item was found in the array\n\t */\n\tcontainsItem(item: T, thisArg?: any): boolean\n}\n\n(() => {\n\tObject.defineProperties(Array.prototype, {\n\t\tremove: {\n\t\t\tvalue: function remove<T>(this: T[], comp: Comparator<T>, thisArg?: any) {\n\t\t\t\tconst index = this.findIndex(comp, thisArg)\n\n\t\t\t\tif (index >= 0) {\n\t\t\t\t\treturn this.splice(index, 1)[0]\n\t\t\t\t}\n\n\t\t\t\treturn undefined\n\t\t\t}\n\t\t},\n\n\t\tremoveItem: {\n\t\t\tvalue: function removeItem<T>(this: T[], item: T, fromIndex = 0) {\n\t\t\t\tconst index = this.indexOf(item, fromIndex)\n\n\t\t\t\tif (index >= 0) {\n\t\t\t\t\treturn this.splice(index, 1)[0]\n\t\t\t\t}\n\n\t\t\t\treturn undefined\n\t\t\t}\n\t\t},\n\n\t\tfirst: {\n\t\t\tget: function first<T>(this: T[]) {\n\t\t\t\treturn this[0]\n\t\t\t},\n\t\t\tset: function first<T>(this: T[], value: T) {\n\t\t\t\tif (this.length) {\n\t\t\t\t\tthis[0] = value\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\tlast: {\n\t\t\tget: function last<T>(this: T[]) {\n\t\t\t\treturn this[this.length - 1]\n\t\t\t},\n\t\t\tset: function last<T>(this: T[], value: T) {\n\t\t\t\tif (this.length) {\n\t\t\t\t\tthis[this.length - 1] = value\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\tsortBy: {\n\t\t\tvalue: function sortBy<T>(this: T[], ...propsOrOptionses: (string | SortOptions<T>)[]): T[] {\n\t\t\t\tconst sorters: Sorter<T>[] = []\n\n\t\t\t\tlet index = 0\n\n\t\t\t\tif (!propsOrOptionses.length) {\n\t\t\t\t\treturn this\n\t\t\t\t}\n\n\t\t\t\tfor (const propOrOptions of propsOrOptionses) {\n\t\t\t\t\tlet descending = false,\n\t\t\t\t\t\tsorter: Sorter<T> | undefined,\n\t\t\t\t\t\taccessor: Accessor<T>\n\n\t\t\t\t\tif (typeof propOrOptions === \"string\") {\n\t\t\t\t\t\taccessor = (item) => item[propOrOptions]\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst options = propOrOptions\n\n\t\t\t\t\t\tdescending = Boolean(options.descending)\n\n\t\t\t\t\t\t// If a custom sorter is passed, the descending doesn't\n\t\t\t\t\t\t//   matter. It is ignored.\n\t\t\t\t\t\tif (typeof options.sorter === \"function\") {\n\t\t\t\t\t\t\tsorter = options.sorter\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (typeof options.property === \"string\") {\n\t\t\t\t\t\t\tconst prop = options.property\n\n\t\t\t\t\t\t\taccessor = (item) => item[prop]\n\t\t\t\t\t\t} else if (typeof options.accessor === \"function\") {\n\t\t\t\t\t\t\taccessor = options.accessor\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Don't do any sorting here if the property or\n\t\t\t\t\t\t\t//   accessor isn't defined\n\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!sorter) {\n\t\t\t\t\t\tsorter = defaultSorter(accessor, descending)\n\t\t\t\t\t}\n\n\t\t\t\t\tsorters.push(sorter)\n\t\t\t\t}\n\n\t\t\t\tfunction defaultSorter(accessor: Accessor<T>, descending: boolean) {\n\t\t\t\t\treturn (lhs: T, rhs: T) => {\n\t\t\t\t\t\tconst lhv = accessor(lhs),\n\t\t\t\t\t\t\trhv = accessor(rhs)\n\n\t\t\t\t\t\tif (lhv === rhv) {\n\t\t\t\t\t\t\treturn 0\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (descending ? lhv < rhv : lhv > rhv) {\n\t\t\t\t\t\t\treturn 1\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn -1\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tthis.sort(recursiveSorter)\n\n\t\t\t\tfunction recursiveSorter(lhs: T, rhs: T) {\n\t\t\t\t\tlet order = 0\n\n\t\t\t\t\tif (sorters.length > index) {\n\t\t\t\t\t\torder = sorters[index](lhs, rhs)\n\n\t\t\t\t\t\tif (!order) {\n\t\t\t\t\t\t\tindex++\n\t\t\t\t\t\t\torder = recursiveSorter(lhs, rhs)\n\t\t\t\t\t\t\tindex--\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn order\n\t\t\t\t}\n\n\t\t\t\treturn this\n\t\t\t}\n\t\t},\n\n\t\tcontains: {\n\t\t\tvalue: function contains<T>(this: T[], comp: Comparator<T>, thisArg?: any) {\n\t\t\t\treturn this.findIndex(comp, thisArg) >= 0\n\t\t\t}\n\t\t},\n\n\t\tcontainsItem: {\n\t\t\tvalue: function containsItem<T>(this: T[], item: T, thisArg?: any) {\n\t\t\t\treturn this.indexOf(item, thisArg) >= 0\n\t\t\t}\n\t\t}\n\t})\n})()\n","type MemoizeOptions = {\n\t/**\n\t * Array of indices to skip as keys. Default is `[]`.\n\t */\n\texcludedArguments?: number[]\n\n\t/**\n\t *  Number of params expected. Arguments will be truncated or padded to\n\t *    reach this number. Default is num of parameters of first call.\n\t */\n\targumentsCount?: number\n\n\t/**\n\t * Whether it is an async function. Defalut is `false`,\n\t */\n\tasynchronous?: boolean\n}\n\ntype Cache = {\n\t[key: string]: Cache | any\n\n\tvalue?: any\n}\n\ninterface Function {\n\t/**\n\t * This allows the arguments of this function to be bound to given values,\n\t *   similar to bind, but it doesn't affect the `this` parameter. It returns\n\t *   a callback that accepts the parameters that are left.\n\t *\n\t * @param firstArgument - the thing to bind as the first arument\n\t *\n\t * @return - the bound function\n\t */\n\tcurry(...args: any[]): any\n\n\t/**\n\t * This memoizes a function that takes non-function parameters as the keys.\n\t *   It necessarily means that the same inputs will always result in the\n\t *   same outputs. If this isn't true, the memoized function will return\n\t *   incorrect values for future calls. Non-string arguments are JSONified\n\t *   before using as a key.\n\t *\n\t * @param {T} func - the function to be memoized\n\t * @param {IMemoizeOptions} options - the options for this function\n\t *\n\t * @return {T} the memoized version of the function\n\t */\n\tmemoize<T extends Function>(this: T, options?: MemoizeOptions): T\n\n\t/**\n\t * Returns a function that will only be called once every however many\n\t *   milliseconds, no matter how many times it is invoked in that time,\n\t *\n\t * @param: number - how long to wait, in milliseconds. Default is `0`.\n\t * @param: imediate - whether to call on the leading edge or the trailing\n\t *   edge. Default is `true`.\n\t */\n\tthrottle<T extends Function>(this: T, wait?: number, immediate?: boolean): T\n\n\t/**\n\t * Returns a function, that, as long as it continues to be invoked, will not\n\t *   be triggered. The function will be invoked after it stops being invoked\n\t *   for however many milliseconds.\n\t *\n\t * @param: number - how long to wait, in milliseconds. Default is `0`.\n\t * @param: imediate - whether to call on the leading edge or the trailing\n\t *   edge. Default is `fase`.\n\t */\n\tdebounce<T extends Function>(this: T, wait?: number, immediate?: boolean): T\n}\n\n(() => {\n\tlet $$memoizeUniqueId = 0\n\n\tObject.defineProperties(Function.prototype, {\n\t\tcurry: {\n\t\t\tvalue: function curry<T extends Function>(this: T, ...args: any[]) {\n\t\t\t\tconst that = this\n\n\t\t\t\treturn function curried(this: any) {\n\t\t\t\t\treturn that.apply(this, args.concat(Array.prototype.slice.call(arguments, 0)))\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\tmemoize: {\n\t\t\tvalue: function memoize<T extends Function>(this: T, options: MemoizeOptions = {}): T {\n\t\t\t\t// Default options\n\t\t\t\tconst defaults: MemoizeOptions = {\n\t\t\t\t\texcludedArguments: [],\n\t\t\t\t\targumentsCount: undefined,\n\t\t\t\t\tasynchronous: false\n\t\t\t\t}\n\n\t\t\t\tfor (const key in defaults) {\n\t\t\t\t\tif (!(key in options)) {\n\t\t\t\t\t\toptions[key] = defaults[key]\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst that = this,\n\t\t\t\t\tcache: Cache = {}\n\n\t\t\t\treturn function memoized(this: any) {\n\t\t\t\t\tconst keys = Array.prototype.filter.call(arguments, function removeFromKeys(obj: any, index: number) {\n\t\t\t\t\t\treturn options.excludedArguments!.indexOf(index) < 0\n\t\t\t\t\t})\n\n\t\t\t\t\tif (typeof options.argumentsCount === \"number\" && isFinite(options.argumentsCount)) {\n\t\t\t\t\t\tkeys.length = options.argumentsCount\n\t\t\t\t\t} else if (keys.length !== options.argumentsCount) {\n\t\t\t\t\t\toptions.argumentsCount = keys.length\n\t\t\t\t\t}\n\n\t\t\t\t\tlet subcache = cache\n\n\t\t\t\t\twhile (keys.length) {\n\t\t\t\t\t\tlet argument: string | any = keys.shift()\n\n\t\t\t\t\t\t// If the parameter is not a string, stringify it to JSON\n\t\t\t\t\t\tif (typeof argument !== \"string\") {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tif (!(\"$$memoizeUniqueId\" in argument)) {\n\t\t\t\t\t\t\t\t\tObject.defineProperty(argument, \"$$memoizeUniqueId\", {\n\t\t\t\t\t\t\t\t\t\tvalue: $$memoizeUniqueId++ + \"_$$memoizeUniqueId\"\n\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\targument = argument.$$memoizeUniqueId\n\t\t\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\targument = JSON.stringify(argument)\n\t\t\t\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t\t\t\targument = String(argument)\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (!(argument in subcache)) {\n\t\t\t\t\t\t\tsubcache = subcache[argument] = {}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tsubcache = subcache[argument]\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!(\"value\" in subcache)) {\n\t\t\t\t\t\tsubcache.value = that.apply(this, arguments)\n\n\t\t\t\t\t\tif (options.asynchronous) {\n\t\t\t\t\t\t\tsubcache.value.catch(function unsave() {\n\t\t\t\t\t\t\t\tdelete subcache.value\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn subcache.value\n\t\t\t\t} as any\n\t\t\t}\n\t\t},\n\n\t\tthrottle: {\n\t\t\tvalue: function throttle<T extends Function>(this: T, wait = 0, immediate = true): T {\n\t\t\t\tconst func = this\n\n\t\t\t\tlet timeout: any\n\n\t\t\t\treturn function throttled(this: any) {\n\t\t\t\t\tconst context = this,\n\t\t\t\t\t\targs = arguments\n\n\t\t\t\t\tif (immediate && !timeout) {\n\t\t\t\t\t\tfunc.apply(context, arguments)\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!timeout) {\n\t\t\t\t\t\ttimeout = setTimeout(() => {\n\t\t\t\t\t\t\ttimeout = undefined\n\n\t\t\t\t\t\t\tif (!immediate) {\n\t\t\t\t\t\t\t\tfunc.apply(context, args)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}, wait)\n\t\t\t\t\t}\n\t\t\t\t} as any\n\t\t\t}\n\t\t},\n\n\t\tdebounce: {\n\t\t\tvalue: function debounce<T extends Function>(this: T, wait = 0, immediate = false): T {\n\t\t\t\tconst func = this\n\n\t\t\t\tlet timeout: any\n\n\t\t\t\treturn function debounced(this: any) {\n\t\t\t\t\tconst context = this,\n\t\t\t\t\t\targs = arguments\n\n\t\t\t\t\tif (immediate && !timeout) {\n\t\t\t\t\t\tfunc.apply(context, args)\n\t\t\t\t\t}\n\n\t\t\t\t\tclearTimeout(timeout)\n\t\t\t\t\ttimeout = setTimeout(() => {\n\t\t\t\t\t\ttimeout = undefined\n\n\t\t\t\t\t\tif (!immediate) {\n\t\t\t\t\t\t\tfunc.apply(context, args)\n\t\t\t\t\t\t}\n\t\t\t\t\t}, wait)\n\t\t\t\t} as any\n\t\t\t}\n\t\t}\n\t})\n})()\n","type TopAndLeft = {\n\ttop?: number,\n\tleft?: number\n}\n\ninterface HTMLElement {\n\t/**\n\t * Whether this element is still a child of the document's body\n\t */\n\treadonly inDOM: boolean\n\n\t/**\n\t * The highest non-null parent element of this element\n\t */\n\treadonly highestParent: HTMLElement | undefined\n\n\t/**\n\t * Get whether this element is scrollable (has overflowX or overflowY as\n\t *   auto or scroll)\n\t */\n\treadonly isScrollable: boolean\n\n\t/**\n\t * Get the first parent of this element that is scrollable\n\t */\n\treadonly scrollableParent: HTMLElement | undefined\n\n\t/**\n\t * Get the top of this element from the top of the direct parent\n\t */\n\tparentTop: number\n\n\t/**\n\t * Get the top of this element from the top of the browser viewport\n\t */\n\tabsoluteTop: number\n\n\t/**\n\t * Get the total offset from the top of the html tag to this element\n\t */\n\ttotalOffsetTop: number\n\n\t/**\n\t * Get the left of this element from the left of the direct parent\n\t */\n\tparentLeft: number\n\t/**\n\t * Get the left of this element from the left of the browser viewport\n\t */\n\tabsoluteLeft: number\n\n\t/**\n\t * Get the total offset from the left of the html tag to this element\n\t */\n\ttotalOffsetLeft: number\n\n\t/**\n\t * Animated scroll from the current scroll to the passed value.\n\t *\n\t * @param {number} topOrOptions - the new scroll top value, or an options\n\t *   that define either top or left.\n\t * @param {number} duration - the duration to use. Default is 250.\n\t * @param {string} timing - the timing function. Default is \"ease-out\".\n\t */\n\tscrollTo(topOrOptions: number | TopAndLeft, duration ?: number, timing ?: string): void\n\n\t/**\n\t * Try to animatedly scroll this into view, if needed.\n\t *\n\t * @param {number} duration - the duration to use. Default is 250.\n\t * @param {string} timing - the timing function. Default is \"ease-out\".\n\t */\n\tscrollIntoViewIfNeeded(duration ?: number, padding ?: number, timing ?: string): void\n}\n\n(() => {\n\ttype Animator = (time: number) => boolean\n\n\tfunction addAnimator(animator: Animator) {\n\t\twindow.requestAnimationFrame((now) => animator(now) && addAnimator(animator))\n\t}\n\n\tObject.defineProperties(HTMLElement.prototype, {\n\t\tinDOM: {\n\t\t\tget: function inDOM(this: HTMLElement): boolean {\n\t\t\t\treturn document.documentElement.contains(this)\n\t\t\t}\n\t\t},\n\n\t\thighestParent: {\n\t\t\tget: function highestParent(this: HTMLElement): HTMLElement | undefined {\n\t\t\t\tlet parent = this\n\n\t\t\t\twhile (parent.parentElement) {\n\t\t\t\t\tparent = parent.parentElement\n\t\t\t\t}\n\n\t\t\t\treturn parent\n\t\t\t}\n\t\t},\n\n\t\tisScrollable: {\n\t\t\tget: function(this: HTMLElement): boolean {\n\t\t\t\tconst style = window.getComputedStyle(this)\n\n\t\t\t\treturn style.overflowY === \"auto\" || style.overflowY === \"scroll\"\n\t\t\t}\n\t\t},\n\n\t\tscrollableParent: {\n\t\t\tget: function(this: HTMLElement): HTMLElement | undefined {\n\t\t\t\tlet parent = this.parentElement\n\n\t\t\t\twhile (parent && !parent.isScrollable) {\n\t\t\t\t\tparent = parent.parentElement\n\t\t\t\t}\n\n\t\t\t\treturn parent\n\t\t\t}\n\t\t},\n\n\t\tparentTop: {\n\t\t\tget: function(this: HTMLElement): number {\n\t\t\t\tlet offset = this.totalOffsetTop\n\n\t\t\t\tif (!this.parentElement) {\n\t\t\t\t\treturn offset\n\t\t\t\t}\n\n\t\t\t\treturn offset - this.parentElement.totalOffsetTop\n\t\t\t}\n\t\t},\n\n\t\tabsoluteTop: {\n\t\t\tget: function(this: HTMLElement): number {\n\t\t\t\tlet element = this,\n\t\t\t\t\toffset = 0\n\n\t\t\t\tdo {\n\t\t\t\t\toffset += element.parentTop\n\n\t\t\t\t\tif (element.parentElement) {\n\t\t\t\t\t\toffset -= element.parentElement.scrollTop\n\t\t\t\t\t}\n\n\t\t\t\t\telement = element.parentElement\n\t\t\t\t} while (element)\n\n\t\t\t\treturn offset\n\t\t\t}\n\t\t},\n\n\t\ttotalOffsetTop: {\n\t\t\tget: function(this: HTMLElement): number {\n\t\t\t\tlet element = this,\n\t\t\t\t\toffset = 0\n\n\t\t\t\tdo {\n\t\t\t\t\toffset += element.offsetTop\n\t\t\t\t\telement = element.offsetParent as HTMLElement\n\t\t\t\t} while (element)\n\n\t\t\t\treturn offset\n\t\t\t}\n\t\t},\n\n\t\tparentLeft: {\n\t\t\tget: function(this: HTMLElement): number {\n\t\t\t\tlet offset = this.totalOffsetLeft\n\n\t\t\t\tif (!this.parentElement) {\n\t\t\t\t\treturn offset\n\t\t\t\t}\n\n\t\t\t\treturn offset - this.parentElement.totalOffsetLeft\n\t\t\t}\n\t\t},\n\n\t\tabsoluteLeft: {\n\t\t\tget: function(this: HTMLElement): number {\n\t\t\t\tlet element = this,\n\t\t\t\t\toffset = 0\n\n\t\t\t\tdo {\n\t\t\t\t\toffset += element.parentLeft\n\n\t\t\t\t\tif (element.parentElement) {\n\t\t\t\t\t\toffset -= element.parentElement.scrollLeft\n\t\t\t\t\t}\n\n\t\t\t\t\telement = element.parentElement\n\t\t\t\t} while (element)\n\n\t\t\t\treturn offset\n\t\t\t}\n\t\t},\n\n\t\ttotalOffsetLeft: {\n\t\t\tget: function(this: HTMLElement): number {\n\t\t\t\tlet element = this,\n\t\t\t\t\toffset = 0\n\n\t\t\t\tdo {\n\t\t\t\t\toffset += element.offsetLeft\n\t\t\t\t\telement = element.offsetParent as HTMLElement\n\t\t\t\t} while (element)\n\n\t\t\t\treturn offset\n\t\t\t}\n\t\t},\n\n\t\tscrollTo: {\n\t\t\tvalue: function(this: HTMLElement, topOrOptions: number | TopAndLeft, duration = 250, timing = \"ease-out\") {\n\t\t\t\tconst startTime = performance.now()\n\n\t\t\t\tlet targetTop: number | undefined,\n\t\t\t\t\ttargetLeft: number | undefined\n\n\t\t\t\tif (typeof topOrOptions === \"number\") {\n\t\t\t\t\ttargetTop = topOrOptions\n\t\t\t\t} else {\n\t\t\t\t\ttargetTop = topOrOptions.top\n\t\t\t\t\ttargetLeft = topOrOptions.left\n\t\t\t\t}\n\n\t\t\t\tif (typeof targetTop === \"number\") {\n\t\t\t\t\tconst start = this.scrollTop,\n\t\t\t\t\t\ttarget = targetTop,\n\t\t\t\t\t\tdown = target > start,\n\t\t\t\t\t\ttween = makeTween(start, target, duration, timing)\n\n\t\t\t\t\tlet expected = start\n\n\t\t\t\t\taddAnimator((time) => {\n\t\t\t\t\t\tconst current = this.scrollTop,\n\t\t\t\t\t\t\tnewScroll = tween(time - startTime)\n\n\t\t\t\t\t\tif (time > startTime + duration || (down ? newScroll >= target : newScroll <= target)) {\n\t\t\t\t\t\t\tthis.scrollTop = target\n\t\t\t\t\t\t} else if (current === expected) {\n\t\t\t\t\t\t\tthis.scrollTop = newScroll\n\n\t\t\t\t\t\t\texpected = this.scrollTop\n\n\t\t\t\t\t\t\treturn true\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn false\n\t\t\t\t\t})\n\t\t\t\t}\n\n\t\t\t\tif (typeof targetLeft === \"number\") {\n\t\t\t\t\tconst start = this.scrollLeft,\n\t\t\t\t\t\ttarget = targetLeft,\n\t\t\t\t\t\tright = target > start,\n\t\t\t\t\t\ttween = makeTween(start, target, duration, timing)\n\n\t\t\t\t\tlet expected = start\n\n\t\t\t\t\taddAnimator((time) => {\n\t\t\t\t\t\tconst current = this.scrollLeft,\n\t\t\t\t\t\t\tnewScroll = tween(time - startTime)\n\n\t\t\t\t\t\tif (time > startTime + duration || (right ? newScroll >= target : newScroll <= target)) {\n\t\t\t\t\t\t\tthis.scrollLeft = target\n\t\t\t\t\t\t} else if (current === expected) {\n\t\t\t\t\t\t\tthis.scrollLeft = newScroll\n\n\t\t\t\t\t\t\texpected = this.scrollLeft\n\n\t\t\t\t\t\t\treturn true\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn false\n\t\t\t\t\t})\n\t\t\t\t}\n\n\t\t\t\tfunction makeTween(start: number, end: number, duration: number, timing?: string): (time: number) => number {\n\t\t\t\t\tlet valueMaker: (x: number) => number\n\n\t\t\t\t\tswitch (timing) {\n\t\t\t\t\t\tcase \"linear\":\n\t\t\t\t\t\t\tvalueMaker = function valueMaker(x) {\n\t\t\t\t\t\t\t\treturn x\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\tcase \"ease-out\":\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tvalueMaker = function valueMaker(x) {\n\t\t\t\t\t\t\t\treturn -Math.pow(x - 1, 2) + 1\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\n\t\t\t\t\treturn function tween(time) {\n\t\t\t\t\t\treturn (end - start) * valueMaker(duration > 0 ? time / duration : 1) + start\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\tscrollIntoViewIfNeeded: {\n\t\t\tvalue: function(this: HTMLElement, duration ?: number, padding = 0, timing ?: string) {\n\t\t\t\ttype Scroller = {\n\t\t\t\t\telement: HTMLElement\n\t\t\t\t\tviewport: {\n\t\t\t\t\t\twidth: number\n\t\t\t\t\t\theight: number\n\t\t\t\t\t}\n\n\t\t\t\t\tscrollLeft: number\n\t\t\t\t\toffsetLeft: number\n\t\t\t\t\twidth: number\n\n\t\t\t\t\tscrollTop: number\n\t\t\t\t\toffsetTop: number\n\t\t\t\t\theight: number\n\t\t\t\t}\n\n\t\t\t\tconst scrollers: Scroller[] = []\n\n\t\t\t\tfor (let curr = this, child = this, offsetTop = 0, offsetLeft = 0; curr.parentElement; curr = curr.parentElement) {\n\t\t\t\t\toffsetTop += curr.parentTop\n\t\t\t\t\toffsetLeft += curr.parentLeft\n\n\t\t\t\t\tif (curr.parentElement.isScrollable) {\n\t\t\t\t\t\tscrollers.push({\n\t\t\t\t\t\t\telement: curr.parentElement,\n\t\t\t\t\t\t\tviewport: {\n\t\t\t\t\t\t\t\twidth: curr.parentElement.clientWidth,\n\t\t\t\t\t\t\t\theight: curr.parentElement.clientHeight\n\t\t\t\t\t\t\t},\n\n\t\t\t\t\t\t\tscrollLeft: curr.parentElement.scrollLeft,\n\t\t\t\t\t\t\toffsetLeft: offsetLeft,\n\t\t\t\t\t\t\twidth: child.offsetWidth,\n\n\t\t\t\t\t\t\tscrollTop: curr.parentElement.scrollTop,\n\t\t\t\t\t\t\toffsetTop: offsetTop,\n\t\t\t\t\t\t\theight: child.offsetHeight\n\t\t\t\t\t\t})\n\n\t\t\t\t\t\toffsetTop = 0\n\t\t\t\t\t\tchild = curr.parentElement\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tscrollers.forEach(function doScroll(options) {\n\t\t\t\t\tlet scrollTop = options.scrollTop,\n\t\t\t\t\t\tscrollLeft = options.scrollLeft\n\n\t\t\t\t\tif (options.offsetTop + options.height > options.viewport.height + options.scrollTop + padding) {\n\t\t\t\t\t\t// Element needs scroll up into the view\n\t\t\t\t\t\tscrollTop = options.offsetTop + options.height - options.viewport.height + padding\n\t\t\t\t\t} else if (options.offsetTop < options.scrollTop - padding) {\n\t\t\t\t\t\t// Element needs scroll down into the view\n\t\t\t\t\t\tscrollTop = options.offsetTop - padding\n\t\t\t\t\t}\n\n\t\t\t\t\tif (options.offsetLeft + options.width > options.viewport.width + options.scrollLeft + padding) {\n\t\t\t\t\t\t// Element needs scroll left into the view\n\t\t\t\t\t\tscrollLeft = options.offsetLeft + options.width - options.viewport.width + padding\n\t\t\t\t\t} else if (options.offsetLeft < options.scrollLeft - padding) {\n\t\t\t\t\t\t// Element needs scroll right into the view\n\t\t\t\t\t\tscrollLeft = options.offsetLeft - padding\n\t\t\t\t\t}\n\n\t\t\t\t\toptions.element.scrollTo({\n\t\t\t\t\t\ttop: scrollTop,\n\t\t\t\t\t\tleft: scrollLeft\n\t\t\t\t\t}, duration, timing)\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\t})\n})()\n","type Watcher = (newValue: any, oldValue: any, property: string) => void\n\ninterface Object {\n\t/**\n\t * Merge other objects into this object\n\t *\n\t * @param others - the other objects to be merged into this one\n\t *\n\t * @return {T} - the final combined object\n\t */\n\tmerge<T extends Object>(this: T, ...others: T[]): T\n\n\t/**\n\t * Override a function on a specific instance only; this one. This\n\t *   puts the old implementation under this._super[func], so that you\n\t *   can still call the original implementation.\n\t *\n\t * @param func - the property corresponding to the function\n\t * @param newFunc - the new function to put in its place\n\t *\n\t * @return {T} - this same object\n\t */\n\toverride<T extends Object>(this: T, func: string, newFunc: Function): T\n\n\t/**\n\t * This sets a single property watcher on an object watching the passed\n\t *   variable. It will reset all other watchers and set only the ones\n\t *   passed here.\n\t *\n\t * @param property - the property to watch\n\t * @param didSet - the callback for after setting\n\t * @param willSet - the callback for before setting\n\t *\n\t * @return {T} this object\n\t */\n\tsetWatcher<T extends Object>(this: T, property: string, didSet?: Watcher, willSet?: Watcher): T\n\n\t/**\n\t * This will add the passed watchers for the passed property.\n\t *\n\t * @param property - the property to watch\n\t * @param didSet - the callback for after setting\n\t * @param willSet - the callback for before setting\n\t *\n\t * @return {T} this object\n\t */\n\taddWatcher<T extends Object>(this: T, property: string, didSet?: Watcher, willSet?: Watcher): T\n\n\t/**\n\t * This will remove the passed watchers on passed property, or all watchers\n\t *   if no watchers passed.\n\t *\n\t * @param property - the property in question\n\t * @param didSet - the watcher that fires after setting\n\t * @param willSet - the watcher that fires before setting\n\t *\n\t * @return {T} this object\n\t */\n\tremoveWatcher<T extends Object>(this: T, property?: string, didSet?: Watcher, willSet?: Watcher): T\n\n\t/**\n\t * This will follow a series of ids to find a nested property.\n\t *\n\t * @param {...*<String>} properties - the properties to follow\n\t * @return {Object?} the found property or undefined\n\t */\n\tgetNestedProperty(...properties: string[]): any\n\n\t/**\n\t * Get an array of all of the values of an object's keys\n\t *\n\t * @return {Object[]} all of the values\n\t */\n\tvaluesArray: any[]\n}\n\n(() => {\n\tinterface OverridenObject extends Object {\n\t\t_super: { [name: string]: Function }\n\t}\n\n\tinterface WatchedObject extends Object {\n\t\t_values: { [property: string]: any }\n\t\t_didSets: { [property: string]: Watcher[] }\n\t\t_willSets: { [property: string]: Watcher[] }\n\t}\n\n\tObject.defineProperties(Object.prototype, {\n\t\tmerge: {\n\t\t\tvalue: function override<T extends Object>(this: T, ...others: T[]) {\n\t\t\t\tothers.forEach((one: T) => {\n\t\t\t\t\tif (one) {\n\t\t\t\t\t\tfor (const key in one) {\n\t\t\t\t\t\t\tif (one.hasOwnProperty(key)) {\n\t\t\t\t\t\t\t\tconst desc = Object.getOwnPropertyDescriptor(one, key)\n\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tObject.defineProperty(this, key, desc)\n\t\t\t\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t\t\t\t// Silent failure on trying to override non-\n\t\t\t\t\t\t\t\t\t//   configurable properties.\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t})\n\n\t\t\t\treturn this\n\t\t\t}\n\t\t},\n\t\toverride: {\n\t\t\tvalue: function override<T extends OverridenObject>(this: T, func: string, newFunc: Function): T {\n\t\t\t\tif (!this._super) {\n\t\t\t\t\tthis._super = {}\n\t\t\t\t}\n\n\t\t\t\tif (!this._super[func]) {\n\t\t\t\t\tthis._super[func] = this[func]\n\t\t\t\t}\n\n\t\t\t\tthis[func] = newFunc\n\n\t\t\t\treturn this\n\t\t\t}\n\t\t},\n\t\tsetWatcher: {\n\t\t\tvalue: function setWatcher<T extends WatchedObject>(this: T, property: string, didSet?: Watcher, willSet?: Watcher): T {\n\t\t\t\tthis.removeWatcher(property)\n\n\t\t\t\treturn this.addWatcher(property, didSet, willSet)\n\t\t\t}\n\t\t},\n\t\taddWatcher: {\n\t\t\tvalue: function addWatcher<T extends WatchedObject>(this: T, property: string, didSet?: Watcher, willSet?: Watcher): T {\n\t\t\t\tif (!this._values) {\n\t\t\t\t\tObject.defineProperty(this, \"_values\", {\n\t\t\t\t\t\tvalue: {}\n\t\t\t\t\t})\n\t\t\t\t}\n\n\t\t\t\tif (!this._willSets) {\n\t\t\t\t\tObject.defineProperty(this, \"_willSets\", {\n\t\t\t\t\t\tvalue: {}\n\t\t\t\t\t})\n\t\t\t\t}\n\n\t\t\t\tif (!this._didSets) {\n\t\t\t\t\tObject.defineProperty(this, \"_didSets\", {\n\t\t\t\t\t\tvalue: {}\n\t\t\t\t\t})\n\t\t\t\t}\n\n\t\t\t\tif (typeof willSet === \"function\") {\n\t\t\t\t\tif (!this._willSets[property]) {\n\t\t\t\t\t\tthis._willSets[property] = []\n\t\t\t\t\t}\n\n\t\t\t\t\tif (this._willSets[property].indexOf(willSet) < 0) {\n\t\t\t\t\t\tthis._willSets[property].push(willSet)\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (typeof didSet === \"function\") {\n\t\t\t\t\tif (!this._didSets[property]) {\n\t\t\t\t\t\tthis._didSets[property] = []\n\t\t\t\t\t}\n\n\t\t\t\t\tif (this._didSets[property].indexOf(didSet) < 0) {\n\t\t\t\t\t\tthis._didSets[property].push(didSet)\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst makeApplyer = (context: Object, newValue: any, oldValue: any, property: string) =>\n\t\t\t\t(callback: Watcher) => callback.call(context, newValue, oldValue, property)\n\n\t\t\t\tthis._values[property] = this[property]\n\t\t\t\tdelete this[property]\n\n\t\t\t\tObject.defineProperty(this, property, {\n\t\t\t\t\tget: function getProperty(this: WatchedObject) {\n\t\t\t\t\t\treturn this._values[property]\n\t\t\t\t\t},\n\t\t\t\t\tset: function setProperty(this: WatchedObject, newValue: any) {\n\t\t\t\t\t\tconst oldValue = this._values[property]\n\n\t\t\t\t\t\tif (this._willSets[property]) {\n\t\t\t\t\t\t\tthis._willSets[property].forEach(makeApplyer(this, newValue, oldValue, property))\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tthis._values[property] = newValue\n\n\t\t\t\t\t\tif (this._didSets[property]) {\n\t\t\t\t\t\t\tthis._didSets[property].forEach(makeApplyer(this, newValue, oldValue, property))\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn newValue\n\t\t\t\t\t},\n\t\t\t\t\tenumerable: true,\n\t\t\t\t\tconfigurable: true\n\t\t\t\t})\n\n\t\t\t\treturn this\n\t\t\t}\n\t\t},\n\t\tremoveWatcher: {\n\t\t\tvalue: function removeWatcher<T extends WatchedObject>(this: T, property: string, didSet?: Watcher, willSet?: Watcher) {\n\t\t\t\tif (typeof didSet !== \"function\" && typeof willSet !== \"function\") {\n\t\t\t\t\t// remove all callbacks for this property\n\t\t\t\t\tif (this._willSets && this._willSets[property]) {\n\t\t\t\t\t\tthis._willSets[property].length = 0\n\t\t\t\t\t}\n\n\t\t\t\t\t// remove all callbacks for this property\n\t\t\t\t\tif (this._didSets && this._didSets[property]) {\n\t\t\t\t\t\tthis._didSets[property].length = 0\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// remove just the passed watcher\n\t\t\t\t\tif (this._willSets && this._willSets[property] && typeof willSet === \"function\") {\n\t\t\t\t\t\tremoveFromArray(this._willSets[property], willSet)\n\t\t\t\t\t}\n\n\t\t\t\t\t// remove just the passed watcher\n\t\t\t\t\tif (this._didSets && this._didSets[property] && typeof didSet === \"function\") {\n\t\t\t\t\t\tremoveFromArray(this._didSets[property], didSet)\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfunction removeFromArray<T>(arr: T[], item: T) {\n\t\t\t\t\tconst i = arr.indexOf(item)\n\n\t\t\t\t\tif (i >= 0) {\n\t\t\t\t\t\tarr.splice(i, 1)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tgetNestedProperty: {\n\t\t\tvalue: function getNestedProperty(this: any, ...properties: string[]): any {\n\t\t\t\tlet value = this\n\n\t\t\t\tfor (const property of properties) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tvalue = value[property]\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\treturn undefined\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn value\n\t\t\t}\n\t\t},\n\t\tvaluesArray: {\n\t\t\tget: function valuesArray(this: Object): any[] {\n\t\t\t\tconst values: any[] = []\n\n\t\t\t\tfor (const key in this) {\n\t\t\t\t\tvalues.push(this[key])\n\t\t\t\t}\n\n\t\t\t\treturn values\n\t\t\t}\n\t\t}\n\t})\n})()\n","interface String {\n\t/**\n\t * Whether this string contains the passed string.\n\t *\n\t * @param str - the string to find\n\t * @param caseInsensitve - whether to care about case. Default is false.\n\t *\n\t * @return - whether the substring was found\n\t */\n\tcontains(str: string, caseInsensitve?: boolean): boolean\n\n\t/**\n\t * Tries to turn this sentence string into Title Case.\n\t *\n\t * @return - the Title Case string\n\t */\n\ttoTitleCase(): string\n\n\t/**\n\t * Tries to turn this identifier string into snake-case.\n\t *\n\t * @return - the snake-case identifier\n\t */\n\ttoSnakeCase(): string\n\n\t/**\n\t * Tries to turn this identifier string into camelCase.\n\t *\n\t * @return - the camelCase identifier\n\t */\n\ttoCamelCase(): string\n\n\t/**\n\t * Gets a property escaped string ready for use in regular expressions\n\t *\n\t * @return - this string escaped for regular expressions\n\t */\n\ttoRegExpEscaped(): string\n}\n\n(() => {\n\t// Common words that are usually lowercase unless they are the first\n\t//   word in the sentence.\n\tconst lowers = [\n\t\t\t\"A\", \"An\", \"The\", \"And\", \"But\", \"Or\", \"For\", \"Nor\", \"As\", \"At\",\n\t\t\t\"By\", \"For\", \"From\", \"In\", \"Into\", \"Near\", \"Of\", \"On\", \"Onto\", \"To\", \"With\"\n\t\t],\n\n\t\t// Certain words have special case.\n\t\tspecials = [{\n\t\t\texpect: \"Ios\",\n\t\t\tdesire: \"iOS\"\n\t\t}, {\n\t\t\texpect: \"Iphone\",\n\t\t\tdesire: \"iPhone\"\n\t\t}, {\n\t\t\texpect: \"Ipad\",\n\t\t\tdesire: \"iPad\"\n\t\t}, {\n\t\t\texpect: \"Ipod\",\n\t\t\tdesire: \"iPod\"\n\t\t}, {\n\t\t\texpect: \"Watchos\",\n\t\t\tdesire: \"watchOS\"\n\t\t}, {\n\t\t\texpect: \"Macos\",\n\t\t\tdesire: \"macOS\"\n\t\t}, {\n\t\t\texpect: \"Os\",\n\t\t\tdesire: \"OS\"\n\t\t}, {\n\t\t\texpect: \"Htc\",\n\t\t\tdesire: \"HTC\"\n\t\t}, {\n\t\t\texpect: \"Zte\",\n\t\t\tdesire: \"ZTE\"\n\t\t}, {\n\t\t\texpect: \"Lg\",\n\t\t\tdesire: \"LG\"\n\t\t}],\n\n\t\tignores = [\n\t\t\t\"US\",\n\t\t\t\"RIM\"\n\t\t]\n\n\tObject.defineProperties(String.prototype, {\n\t\tcontains: {\n\t\t\tvalue: function contains(this: string, str: string, caseInsensitve = false) {\n\t\t\t\treturn new RegExp(str.toRegExpEscaped(), caseInsensitve ? \"i\" : \"\").test(this)\n\t\t\t}\n\t\t},\n\n\t\ttoTitleCase: {\n\t\t\tvalue: function toTitleCase(this: string) {\n\t\t\t\tlet str = this.replace(\n\t\t\t\t\t/([^\\W_]+[^\\s-]*)(?=\\s*)/g,\n\t\t\t\t\t(txt) => ignores.indexOf(txt) >= 0\n\t\t\t\t\t\t? txt\n\t\t\t\t\t\t: txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase()\n\t\t\t\t)\n\n\t\t\t\tfor (const lower of lowers) {\n\t\t\t\t\tstr = str.replace(new RegExp(\"[\\\\s\\\\-]\" + lower + \"[\\\\s\\\\-]\", \"g\"), (txt) => txt.toLowerCase())\n\t\t\t\t}\n\n\t\t\t\tfor (const special of specials) {\n\t\t\t\t\tstr = str.replace(new RegExp(\"\\\\b\" + special.expect + \"\\\\b\", \"g\"), special.desire)\n\t\t\t\t}\n\n\t\t\t\treturn str\n\t\t\t}\n\t\t},\n\n\t\ttoSnakeCase: {\n\t\t\tvalue: function toSnakeCase(this: string) {\n\t\t\t\tif (/^[A-Z_0-9]+$/.test(this)) {\n\t\t\t\t\treturn this.toLowerCase().replace(/_/g, \"-\")\n\t\t\t\t}\n\n\t\t\t\treturn this.replace(/(?!^)([A-Z])/g, \"-$1\").toLowerCase()\n\t\t\t}\n\t\t},\n\n\t\ttoCamelCase: {\n\t\t\tvalue: function toSnakeCase(this: string) {\n\t\t\t\treturn this.toLowerCase().replace(/^[_-]*|([_-][a-z])/g, (_: string, match: string) => match.toUpperCase())\n\t\t\t}\n\t\t},\n\n\t\ttoRegExpEscaped: {\n\t\t\tvalue: function toRegExpEscaped(this: string) {\n\t\t\t\treturn this.replace(/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, \"\\\\$&\")\n\t\t\t}\n\t\t}\n\t})\n})()\n"]}